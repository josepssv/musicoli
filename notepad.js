class Notepad {
  constructor(options = {}) {
    // Configuraci√≥n por defecto
    const defaults = {
      parent: document.body,
      width: 600,
      height: 300,
      fontSize: 20,
      fontFamily: 'monospace',
      colors: ['transparent'],
      noteColorMap: {},
      colorMap: {},
      colorSequence: null,
      colorFunc: null,
      insertionMode: 'word', // 'letter', 'word', 'plain-letter', 'plain-word' 
      letterPadY: 2,
      letterPadX: 4,
      letterMarginX: 0,
      letterBorderRadius: 4,
      letterBorderWidth: 0,
      letterBorderColor: '#000000',
      textColor: '#ffffff',
      textColorFunc: null,
      containerPadding: '0px',
      editable: true,
      overwriteMode: false,
      transform: 'skew(25deg)',
      boxShadow: '0px 3px 8px #EC00F4',
      textAlign: 'left',
      textPerspective: true,
      textPerspectiveSharp: true,
      textPerspectiveSameHeight: true,
    };

    // Merge de opciones
    this.opts = { ...defaults, ...options };

    // Legacy compatibilit
    if (this.opts.colorMap && Object.keys(this.opts.noteColorMap).length === 0) {
      this.opts.noteColorMap = this.opts.colorMap;
    }

    // State
    this.letterNodes = [];
    this.cursorPos = 0;
    this.selectionStart = null;
    this.selectionEnd = null;
    this.clipboard = [];
    this.handlers = {};
    this.isDragging = false;
    this.overwriteMode = this.opts.overwriteMode;
    this.isEditable = this.opts.editable;
    this.editingIndex = null;
    this.editingOffset = 0;
    this._isTypingInWord = false;
    this._lastClickTime = 0;
    this._seqIndex = 0;
    this.isComposing = false;

    // Modo texto plano
    this._plainTextMode = false;
    this._originalStates = null;
    this._plainTextColor = '#000000';
    // Imagen
    this.img = null;
    this.images = []
    this.p5 = null;
    this.imagePath = 'data:image/png;base64,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'
    //this.imagePath = 'mari.png';
    // Initialize
    this._iniSketch();
    this._build();
    this._attachEvents();
    this._render();
    this._cssValuePrefix = this.getCssValuePrefix();


  }

  // ---------------- Public API ----------------

  _iniSketch() {

    const sketch = (s) => {

      s.preload = () => {
        this.img = s.loadImage(this.imagePath);
      }
      s.setup = () => {
        s.noCanvas();
        for (let x = 0; x < 39; x++) {
          var cx = s.random(this.img.width);
          var cy = s.random(this.img.height);
          let imi = this.img.get(cx, cy, this.opts.fontSize, this.opts.fontSize);
          imi.loadPixels();
          imi.updatePixels();
          this.images[x] = imi.canvas.toDataURL()
        }
      };


    }
    this.p5 = new p5(sketch);
  }



  getCssValuePrefix() {
    var rtrnVal = '';//default to standard syntax
    var prefixes = ['-o-', '-ms-', '-moz-', '-webkit-'];

    // Create a temporary DOM object for testing
    var domi = document.createElement('div');

    for (var i = 0; i < prefixes.length; i++) {
      // Attempt to set the style
      domi.style.background = prefixes[i] + 'linear-gradient(#000000, #ffffff)';
      // Detect if the style was successfully set
      if (domi.style.background) {
        rtrnVal = prefixes[i];
      }
    }
    //domi = null;
    //delete domi;
    return rtrnVal;
  }


  focus() { try { this.textarea.focus(); } catch (e) { } }

  get noteColorMap() { return this.opts.noteColorMap; }
  set noteColorMap(val) { this.opts.noteColorMap = val; this.recolor(); }

  insertText(text) {
    for (let ch of text) {
      this._insertChar(ch);
    }
    this._emit('change');
    this._render();
  }

  setText(text) {
    this._clearAll();
    for (let ch of text) this._insertChar(ch);
    this._render();
    this._emit('change');
  }


  insertTextAsWordBlocks(text, options = {}) {
    const {
      colorFunc = null,
      spaceColor = 'transparent',
      randomColors = true
    } = options;

    const generateRandomColor = () => {
      const hue = Math.floor(Math.random() * 360);
      const saturation = 70 + Math.floor(Math.random() * 30);
      const lightness = 45 + Math.floor(Math.random() * 20);
      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    };

    const words = text.split(' ');
    this._clearAll();

    words.forEach((word, index) => {
      let wordColor;
      if (colorFunc) {
        wordColor = colorFunc(word, index);
      } else if (randomColors) {
        wordColor = generateRandomColor();
      } else {
        wordColor = this._getColorForChar(word[0] || 'a');
      }

      const span = document.createElement('span');
      span.textContent = word;
      span.style.display = 'inline-block';

      // Respetar modo plano si est√° activo
      if (this._plainTextMode) {
        span.style.backgroundColor = 'transparent';
        span.style.color = this._plainTextColor;
        span.style.border = 'none';
        span.dataset.plain = 'true';
      } else {
        span.style.background = wordColor;
        //-->span.style.backgroundImage = 'url(' + this.images[index] + ')';
        //-->span.style.backgroundSize = 'cover';
        //span.style.background = gradient;
        span.style.color = this._resolveTextColor(word[0], this.letterNodes.length, wordColor);
        //span.style.color = '#000000';
        span.style.border = this.opts.letterBorderWidth + 'px solid ' + this.opts.letterBorderColor;
        //->span.style.transform = this.opts.transform;
        //-> span.style.boxShadow = this.opts.boxShadow;
      }

      span.style.padding = `${this.opts.letterPadY}px ${this.opts.letterPadX}px`;
      span.style.margin = (typeof this.opts.letterMarginX === 'number') ? `0 ${this.opts.letterMarginX}px` : this.opts.letterMarginX;
      span.style.borderRadius = this.opts.letterBorderRadius + 'px';
      span.dataset.color = wordColor;
      //span.dataset.color = '#000000';
      span.dataset.isWordBlock = 'true';

      this.letterNodes.push(span);

      if (index < words.length - 1) {
        const spaceSpan = document.createElement('span');
        spaceSpan.textContent = ' ';
        spaceSpan.style.display = 'inline-block';
        spaceSpan.style.backgroundColor = spaceColor;
        spaceSpan.style.color = 'transparent';
        spaceSpan.dataset.color = spaceColor;
        this.letterNodes.push(spaceSpan);
      }
    });

    this.cursorPos = this.letterNodes.length;
    this._render();
    this._emit('change');
  }

  getPlainText() {
    return this.letterNodes.map(node => (node.tagName === 'BR' ? '\n' : node.textContent)).join('');
  }
  getCursorPos() {
    return this.cursorPos;
  }

  getSpanWidths() {
    return this.letterNodes
      .filter(node => node.tagName === 'SPAN')
      .map(node => node.getBoundingClientRect().width);
  }

  getColorInPos(n) {
    if (n) {
      return this.letterNodes[n].dataset.color;
    } else {
      let n = this.cursorPos;
      return this.letterNodes[n].dataset.color;
    };
  }
  setColorInPos(n, color) {
    if (n) {
      this.letterNodes[n].style.backgroundColor = color;
      this._render();
      this._emit('change');
    } else {
      let n = this.cursorPos;
      this.letterNodes[n].style.backgroundColor = color;
      this._render();
      this._emit('change');
    }
  }
  getTextInPos(n) {
    if (n) {
      return this.letterNodes[n].textContent;
    } else {
      let n = this.cursorPos;
      return this.letterNodes[n].textContent;
    };

  }
  setTextInPos(n, text) {
    if (n) {
      this.letterNodes[n].textContent = text;
      this._render();
      this._emit('change');
    } else {
      let n = this.cursorPos;
      this.letterNodes[n].textContent = text;
      this._render();
      this._emit('change');
    }
  }
  getRichContent() {
    return this.letterNodes.map(node => (node.tagName === 'BR' ? { text: '\n', color: null } : { text: node.textContent, color: node.dataset.color || null }));
  }

  getDetailedJSON() {
    return this.letterNodes.map((node, index) => {
      if (node.tagName === 'BR') {
        return {
          index: index,
          char: '\n',
          type: 'newline',
          color: null,
          rgb: null
        };
      }

      const color = node.dataset.color || node.style.backgroundColor || 'transparent';
      let parsed = this._parseColor(color);
      let rgb;
      if (parsed?.type === 'gradient') {
        rgb = parsed.value;
        //-->span.style.color = 'transparent';
      } else if (parsed?.type === 'rgb') {
        rgb = `rgb(${parsed.r},${parsed.g},${parsed.b})`;
      }

      const isPlain = node.dataset.plain === 'true';

      return {
        index: index,
        char: node.textContent,
        type: 'character',
        color: color,
        rgb: rgb,
        isPlain: isPlain,
        padding: {
          y: this.opts.letterPadY,
          x: this.opts.letterPadX
        },
        margin: this.opts.letterMarginX,
        borderRadius: this.opts.letterBorderRadius,
        border: {
          width: this.opts.letterBorderWidth,
          color: this.opts.letterBorderColor
        },
        textColor: node.style.color || this.opts.textColor
      };
    });
  }

  setFromPlainText(text) {
    this._clearAll();
    for (let ch of text) this._insertChar(ch);
    this._render();
    this._emit('change');
  }

  setFromRichContent(arr) {
    this._clearAll();
    for (let item of arr) {
      if (item.text === '\n') this._insertNewline();
      else this._insertChar(item.text, item.color);
    }
    // SOLICITADO POR MUSICOLI: Position cursor at the end by default for future insertions
    // This allows new compases (spans) to be inserted at the end, preparing for future implementation
    // where insertions can be made at the marked position
    this.cursorPos = this.letterNodes.length;
    this._render();
    this._emit('change');
  }

  copy() {
    const range = this._getSelectionRange();
    if (!range) return;
    this.clipboard = [];
    for (let i = range.start; i < range.end; i++) {
      const n = this.letterNodes[i];
      if (n.tagName === 'BR') this.clipboard.push({ text: '\n', color: null });
      else this.clipboard.push({ text: n.textContent, color: n.dataset.color || null });
    }
    try {
      const plain = this.clipboard.map(o => o.text).join('');
      navigator.clipboard && navigator.clipboard.writeText(plain).catch(() => { });
    } catch (e) { }
    this._emit('copy', this.clipboard.slice());
  }

  cut() {
    const range = this._getSelectionRange();
    if (!range) return;
    this.copy();
    for (let i = range.end - 1; i >= range.start; i--) {
      this.letterNodes[i].remove();
      this.letterNodes.splice(i, 1);
    }
    this.cursorPos = range.start;
    this._clearSelection();
    this._render();
    this._emit('change');
  }

  paste() {
    if (!this.clipboard || this.clipboard.length === 0) return;

    if (this.overwriteMode) {
      const range = this._getSelectionRange();
      let startPos = range ? range.start : this.cursorPos;
      let pasteIdx = 0;
      let pasteText = "";
      for (let item of this.clipboard) pasteText += item.text;

      for (let i = startPos; i < this.letterNodes.length && pasteIdx < pasteText.length; i++) {
        const node = this.letterNodes[i];
        if (node.tagName === 'BR') continue;
        node.textContent = pasteText[pasteIdx];
        pasteIdx++;
      }

      if (range && (startPos + pasteIdx) < range.end) {
        for (let i = startPos + pasteIdx; i < range.end; i++) {
          const node = this.letterNodes[i];
          if (node.tagName !== 'BR') node.textContent = ' ';
        }
      }

      this.cursorPos = Math.min(this.letterNodes.length, startPos + pasteIdx);
      this._clearSelection();
      this._render();
      this._emit('change');
      return;
    }

    const range = this._getSelectionRange();
    if (range) {
      for (let i = range.end - 1; i >= range.start; i--) {
        this.letterNodes[i].remove();
        this.letterNodes.splice(i, 1);
      }
      this.cursorPos = range.start;
      this._clearSelection();
    }
    for (let item of this.clipboard) {
      if (item.text === '\n') this._insertNewline();
      else this._insertChar(item.text, item.color);
    }
    this._emit('paste', this.clipboard.slice());
    this._render();
    this._emit('change');
  }

  // ---------------- Modos de Inserci√≥n Planos ----------------

  setInsertionMode(mode) {
    const validModes = ['letter', 'word', 'plain-letter', 'plain-word'];
    if (validModes.includes(mode)) {
      this.opts.insertionMode = mode;
      console.log(`Modo de inserci√≥n cambiado a: ${mode}`);
    } else {
      console.warn(`Modo de inserci√≥n inv√°lido: ${mode}. Modos v√°lidos: ${validModes.join(', ')}`);
    }
  }

  isPlainMode() {
    return this.opts.insertionMode.startsWith('plain-');
  }

  setPlainLetterMode() {
    this.setInsertionMode('plain-letter');
  }

  setPlainWordMode() {
    this.setInsertionMode('plain-word');
  }

  setColorLetterMode() {
    this.setInsertionMode('letter');
  }

  setColorWordMode() {
    this.setInsertionMode('word');
  }

  // ---------------- Modo Texto Plano (Visualizaci√≥n) ----------------

  setPlainTextMode(enabled, textColor = '#000000') {
    if (this._plainTextMode === enabled) return;

    this._plainTextMode = enabled;
    this._plainTextColor = textColor;

    if (enabled) {
      // Guardar estados originales
      this._originalStates = this.letterNodes.map(node => {
        if (node.tagName === 'BR') return null;
        return {
          backgroundColor: node.style.backgroundColor,
          color: node.style.color,
          border: node.style.border,
          datasetColor: node.dataset.color,
          isPlain: node.dataset.plain === 'true'
        };
      });

      // Aplicar modo plano
      for (let i = 0; i < this.letterNodes.length; i++) {
        const node = this.letterNodes[i];
        if (node.tagName === 'BR') continue;

        node.style.backgroundColor = 'transparent';

        // MUSICOLI FIX: Always use black for Bravura musical notation
        const ch = node.textContent;
        const charCode = ch && ch.length > 0 ? ch.charCodeAt(0) : 0;
        if (charCode >= 0xE000 && charCode <= 0xF8FF) {
          node.style.color = '#000000'; // Force black for musical notation
        } else {
          node.style.color = textColor;
        }

        node.style.border = 'none';
        node.dataset.plain = 'true';
      }
    } else if (this._originalStates) {
      // Restaurar estados originales
      for (let i = 0; i < this.letterNodes.length; i++) {
        const node = this.letterNodes[i];
        if (node.tagName === 'BR' || !this._originalStates[i]) continue;

        const original = this._originalStates[i];

        if (original.isPlain) {
          // Nodos que eran planos permanecen planos
          node.style.backgroundColor = 'transparent';
          node.style.color = '#000000';
          node.style.border = 'none';
        } else {
          // Restaurar nodos con color
          node.style.backgroundColor = original.backgroundColor;
          node.style.color = original.color;
          node.style.border = original.border || 'none';
          node.dataset.plain = 'false';
        }
      }
      this._originalStates = null;
    }

    this._render();
    this._emit('change');
  }

  togglePlainTextMode() {
    this.setPlainTextMode(!this._plainTextMode, this._plainTextColor);
  }

  isPlainTextMode() {
    return this._plainTextMode;
  }

  // ---------------- Color & background API ----------------

  setNoteColorMap(map) {
    let mapi;
    if (map === null || (map >= 0 && map <= 12) || map === undefined) {
      if (map == null || map == undefined) mapi = Notepad.assignRainbowColors();
      if (map == 1) mapi = Notepad.assignRandomColors();
      if (map == 2) mapi = this.setVerticalGradientRainbowCycleMode(12);
      if (map == 3) mapi = Notepad.assignGradientColors();
    } else {
      mapi = map;
    }

    this.opts.noteColorMap = mapi || map;
    this.recolor();
  }

  setNoteColor(note, color) {
    if (!this.opts.noteColorMap) this.opts.noteColorMap = {};
    if (color == null) delete this.opts.noteColorMap[note];
    else this.opts.noteColorMap[note] = color;
    this.recolor();
  }

  setColorMap(map) {
    this.opts.colorMap = map || {};
    this.recolor();
  }

  setColorSequence(seq) {
    this.opts.colorSequence = (Array.isArray(seq) && seq.length) ? seq.slice() : null;
    this._seqIndex = 0;
    this.recolor();
  }

  setColorFunc(fn) {
    this.opts.colorFunc = (typeof fn === 'function') ? fn : null;
    this.recolor();
  }

  resetSequence() {
    this._seqIndex = 0;
    this.recolor();
  }

  setAppBackground(color) {
    try { document.body.style.backgroundColor = color; } catch (e) { }
  }

  setContainerBackground(color) {
    try { this.container.style.background = color; } catch (e) { }
  }

  setContainerImage(url) {
    try {
      this.container.style.backgroundImage = `url(${url})`;
      this.container.style.backgroundSize = 'cover';
      this.container.style.backgroundPosition = 'center';
      this.container.style.backgroundRepeat = 'no-repeat';
    } catch (e) { }
  }

  setContainerGradient(gradient) {
    try { this.container.style.backgroundImage = gradient; } catch (e) { }
  }

  setContainerBackgrounds(value) {
    try { this.container.style.background = value; } catch (e) { }
  }

  setWarmCycleMode(steps = 10) {
    const colors = Notepad.generateWarmColors(steps);
    let cycleIndex = 0;
    this.setColorFunc((char, index) => {
      if (index === 0) cycleIndex = 0;
      if (char === ' ') return 'transparent';
      const color = colors[cycleIndex % colors.length];
      cycleIndex++;
      return color;
    });
    this.opts.noteColorMap = colors;
    this.recolor();
  }
  setColdCycleMode(steps = 10) {
    const colors = Notepad.generateColdColors(steps);
    let cycleIndex = 0;
    this.setColorFunc((char, index) => {
      if (index === 0) cycleIndex = 0;
      if (char === ' ') return 'transparent';
      const color = colors[cycleIndex % colors.length];
      cycleIndex++;
      return color;
    });
    this.opts.noteColorMap = colors;
    this.recolor();
  }

  setRandomCycleMode(steps = 10) {
    const colors = Notepad.generateRandomColors(steps);
    let cycleIndex = 0;
    this.setColorFunc((char, index) => {
      if (index === 0) cycleIndex = 0;
      if (char === ' ') return 'transparent';
      const color = colors[cycleIndex % colors.length];
      cycleIndex++;
      return color;
    });
    this.opts.noteColorMap = colors;
    this.recolor();
  }
  setRandomCycleMode02(steps = 10) {
    const colors = Notepad.generateRandomColors(35);
    this.setNoteColorMap(colors);
    this.recolor();
  }

  setRainbowCycleMode(steps = 10) {
    const colors = Notepad.generateRainbowColors(steps);
    let cycleIndex = 0;
    this.setColorFunc((char, index) => {
      if (index === 0) cycleIndex = 0;
      if (char === ' ') return 'transparent';
      const color = colors[cycleIndex % colors.length];
      cycleIndex++;
      return color;
    });
    this.opts.noteColorMap = colors;
    this.recolor();
  }


  setDarkLightCycleMode(steps = 10) {
    const colors = Notepad.generateDarkLightColors(steps);
    let cycleIndex = 0;
    this.setColorFunc((char, index) => {
      if (index === 0) cycleIndex = 0;
      if (char === ' ') return 'transparent';
      const color = colors[cycleIndex % colors.length];
      cycleIndex++;
      return color;
    });
    this.opts.noteColorMap = colors;
    this.recolor();
  }

  setGreyScaleCycleMode(steps = 10) {
    const colors = Notepad.generateGreyScaleColors(steps);
    let cycleIndex = 0;
    this.setColorFunc((char, index) => {
      if (index === 0) cycleIndex = 0;
      if (char === ' ') return 'transparent';
      const color = colors[cycleIndex % colors.length];
      cycleIndex++;
      return color;
    });
    this.opts.noteColorMap = colors;
    this.recolor();
  }
  // ---------------- Modo Gradiente ----------------
  setHorizontalGradientRainbowCycleMode(steps = 10) {
    const colors = Notepad.generateRainbowColors(steps);
    let cycleIndex = 0;
    this.setColorFunc((char, index) => {
      if (index === 0) cycleIndex = 0;
      if (char === ' ') return 'transparent';
      const a = colors[cycleIndex % colors.length];
      const b = colors[(cycleIndex + 1) % colors.length];
      cycleIndex++;
      return `linear-gradient(to right, ${a}, ${b})`;
    });

    this.opts.noteColorMap = colors;
    this.recolor();
  }

  setVerticalGradientRainbowCycleMode(steps = 10) {
    const colors = Notepad.generateRainbowColors(steps);
    let cycleIndex = 0;
    this.setColorFunc((char, index) => {
      if (index === 0) cycleIndex = 0;
      if (char === ' ') return 'transparent';

      const a = colors[cycleIndex % colors.length];
      const b = colors[(cycleIndex + 1) % colors.length];

      cycleIndex++;
      return `linear-gradient(to bottom, ${a}, ${b})`;
    });
    this.opts.noteColorMap = colors;
    this.recolor()
  }
  setVerticalGradientGreyScaleCycleMode(steps = 10) {
    const colors = Notepad.generateGreyScaleColors(steps);
    let cycleIndex = 0;

    this.setColorFunc((char, index) => {
      if (index === 0) cycleIndex = 0;
      if (char === ' ') return 'transparent';

      const a = colors[cycleIndex % colors.length];
      const b = colors[(cycleIndex + 1) % colors.length];

      cycleIndex++;
      return `linear-gradient(to bottom, ${a}, ${b})`;
    });
    this.opts.noteColorMap = colors;
    this.recolor();
  }

  setHorizontalGradientGreyScaleCycleMode(steps = 10) {
    const colors = Notepad.generateGreyScaleColors(steps);
    let cycleIndex = 0;

    this.setColorFunc((char, index) => {
      if (index === 0) cycleIndex = 0;
      if (char === ' ') return 'transparent';

      const a = colors[cycleIndex % colors.length];
      const b = colors[(cycleIndex + 1) % colors.length];

      cycleIndex++;
      return `linear-gradient(to right, ${a}, ${b})`;
    });
    this.opts.noteColorMap = colors;
    this.recolor()
  }

  setContainerPadding(padding) {
    this.opts.containerPadding = padding;
    this.container.style.padding = padding;
    this._render();
  }

  setSize(w, h) {
    if (w) {
      this.opts.width = w;
      this.container.style.width = (typeof w === 'number') ? `${w}px` : w;
    }
    if (h) {
      this.opts.height = h;
      this.container.style.height = (typeof h === 'number') ? `${h}px` : h;
    }
  }

  setBorder(width, color, radius) {
    if (width !== null) this.container.style.borderWidth = width + 'px';
    if (color !== null) this.container.style.borderColor = color;
    if (radius !== null) this.container.style.borderRadius = radius + 'px';
    this.container.style.borderStyle = 'solid';
  }

  setOverwriteMode(enabled) {
    this.overwriteMode = !!enabled;
  }

  setEditable(enabled) {
    this.isEditable = !!enabled;
    if (!this.isEditable) {
      this.textarea.blur();
      this._clearSelection();
    }
  }

  setResizable(enabled) {
    if (enabled) {
      this.container.style.resize = 'both';
      this.container.style.overflow = 'auto';
    } else {
      this.container.style.resize = 'none';
    }
  }

  backgroundEqualizer() {
    const objetos = this.getDetailedJSON();

    if (!objetos || objetos.length === 0) return true;

    let sumR = 0, sumG = 0, sumB = 0;
    let count = 0;
    const n = objetos.length;

    objetos.forEach(obj => {
      // Asumimos que cada objeto tiene una propiedad 'color' en formato "rgb(R, G, B)"
      if (obj.color && typeof obj.color === 'string') {
        const rgbMatch = obj.color.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
        if (rgbMatch) {
          const rgb = obj.color.match(/\d+/g);
          sumR += parseInt(rgb[0], 10);
          sumG += parseInt(rgb[1], 10);
          sumB += parseInt(rgb[2], 10);
          count++;
        }
      }
    });
    if (count === 0) return true;
    const media = {
      r: Math.round(sumR / count),
      g: Math.round(sumG / count),
      b: Math.round(sumB / count)
    };

    this.setContainerBackground(`rgb(${media.r}, ${media.g}, ${media.b})`);
  }

  applyBackground(element, value) {
    if (!value) return;

    if (value.startsWith("linear-gradient") || value.startsWith("radial-gradient")) {
      // Gradiente
      element.style.backgroundImage = value;
      element.style.backgroundColor = ""; // limpiar color plano
    } else if (value.startsWith("url(")) {
      // Imagen
      element.style.backgroundImage = value;
      element.style.backgroundColor = ""; // limpiar color plano
    } else {
      // Color plano
      element.style.backgroundColor = value;
      element.style.backgroundImage = ""; // limpiar gradiente/imagen
    }
  }

  recolor() {
    // No recolorear si estamos en modo plano
    if (this._plainTextMode) return;
    for (let i = 0; i < this.letterNodes.length; i++) {
      const n = this.letterNodes[i];
      if (n.tagName === 'BR') continue;
      // Respetar nodos planos
      if (n.dataset.plain === 'true') {
        n.style.backgroundColor = 'transparent';

        // MUSICOLI FIX: Always use black for Bravura musical notation
        const ch = n.textContent;
        const charCode = ch && ch.length > 0 ? ch.charCodeAt(0) : 0;
        if (charCode >= 0xE000 && charCode <= 0xF8FF) {
          n.style.color = '#000000'; // Force black for musical notation
        } else {
          n.style.color = this._plainTextColor;
        }

        n.style.border = 'none';
        continue;
      }
      const ch = n.textContent;
      const col = this._deterministicColorForChar(ch, i);
      this.applyBackground(n, col);
      //n.style.backgroundColor = col;
      //n.style.background = col;

      n.dataset.color = col;
      const textCol = this._resolveTextColor(ch, i, col);
      n.style.color = textCol;

      // Aplicar borde si corresponde
      if (this.opts.letterBorderWidth > 0) {
        n.style.border = this.opts.letterBorderWidth + 'px solid ' + this.opts.letterBorderColor;
      }
    }
    this._render();
  }

  // ---------------- Font / spacing API ----------------

  setTextPerspective(enabled) {
    this.opts.textPerspective = !!enabled;
    this._render();
  }

  setTextPerspectiveSharp(enabled) {
    this.opts.textPerspectiveSharp = !!enabled;
    this._render();
  }

  setTextPerspectiveSameHeight(enabled) {
    this.opts.textPerspectiveSameHeight = !!enabled;
    this._render();
  }

  _updatePerspectiveVisual() {
    if (!this.opts.textPerspective) {
      // Reset if disabled
      for (let i = 0; i < this.letterNodes.length; i++) {
        const node = this.letterNodes[i];
        if (node.tagName !== 'BR') {
          node.style.removeProperty('font-size');
          node.style.removeProperty('height');
          node.style.removeProperty('display');
          node.style.removeProperty('align-items');
          // Reset margin
          const marginVal = (typeof this.opts.letterMarginX === 'number') ? `0 ${this.opts.letterMarginX}px` : this.opts.letterMarginX;
          node.style.margin = marginVal;
          // Reset padding
          node.style.padding = `${this.opts.letterPadY}px ${this.opts.letterPadX}px`;
        }
      }
      return;
    }

    const baseSize = this.opts.fontSize;
    const minSize = 8;
    const activeIndex = this.editingIndex !== null ? this.editingIndex : (this.cursorPos > 0 ? this.cursorPos - 1 : 0);

    // Find screen center if we wanted to base it on scroll, but request says "span actual" (cursor)
    // distance factor - how much size decreases per unit of distance (index distance)
    // Let's drop 1px per step? or more? 
    // Request: "cuanto m√°s alejado est√© el span m√°s peque√±o hasta lo m√≠nimo que vamos a marcar como 8px"
    // Let's try 2px per step to make it visible
    // Calculate step based on sharpness preference
    let sizeStep;
    if (this.opts.textPerspectiveSharp) {
      // Sharp: drop to min size in 4 spans
      // (base - min) / 4
      sizeStep = (baseSize - minSize) / 4;
    } else {
      // Smooth: slower drop, maybe over 10 spans?
      sizeStep = (baseSize - minSize) / 10;
    }

    for (let i = 0; i < this.letterNodes.length; i++) {
      const node = this.letterNodes[i];
      if (node.tagName === 'BR') continue;

      const dist = Math.abs(i - activeIndex);
      let newSize = baseSize - (dist * sizeStep);
      if (newSize < minSize) newSize = minSize;

      node.style.fontSize = newSize + 'px';

      // Scale margin if it's numeric
      if (typeof this.opts.letterMarginX === 'number') {
        const ratio = newSize / baseSize;
        const newMargin = this.opts.letterMarginX * ratio;
        node.style.margin = `0 ${newMargin}px`;
      }

      // Scale horizontal padding
      const ratio = newSize / baseSize;
      let newPadX = this.opts.letterPadX * ratio;
      if (newPadX < 1) newPadX = 1;
      node.style.padding = `${this.opts.letterPadY}px ${newPadX}px ${this.opts.letterPadY + 5}px ${newPadX}px`;

      if (this.opts.textPerspectiveSameHeight) {
        // Force height to match base font size (plus padding if needed) to align elements
        // We use flex to center vertically
        node.style.height = '100%';
        node.style.display = 'inline-flex';
        node.style.alignItems = 'center';
        node.style.justifyContent = 'center';
        // Reset vertical align just in case
        node.style.verticalAlign = 'middle';
      } else {
        node.style.removeProperty('height');
        // Restore default display
        node.style.display = 'inline-block';
        node.style.removeProperty('align-items');
        node.style.removeProperty('justify-content');
        node.style.removeProperty('vertical-align');
      }
    }
  }

  setFont(fontFamily, fontSize) {
    if (fontFamily) {
      this.opts.fontFamily = fontFamily;
      this.container.style.fontFamily = fontFamily;
    }
    if (fontSize) {
      this.opts.fontSize = fontSize;
      this.container.style.fontSize = fontSize + 'px';
    }
    for (const n of this.letterNodes) {
      if (!n || n.tagName === 'BR') continue;
      // MUSICOLI: Skip clearing font properties if custom content is flagged
      if (n.dataset.customContent === 'true') continue;
      n.style.removeProperty('font-family');
      n.style.removeProperty('font-size');
    }
    this.cursor.style.height = (this.opts.fontSize + 4) + 'px';
  }

  setLetterPadding(padY = 2, padX = 4) {
    this.opts.letterPadY = padY;
    this.opts.letterPadX = padX;
    for (const n of this.letterNodes) {
      if (!n || n.tagName === 'BR') continue;
      n.style.padding = `${padY}px ${padX}px`;
    }
  }

  setLetterBorderRadius(radius = 4) {
    this.opts.letterBorderRadius = radius;
    for (const n of this.letterNodes) {
      if (!n || n.tagName === 'BR') continue;
      n.style.borderRadius = radius + 'px';
    }
  }

  setLetterBorder(width, color) {
    if (width !== null && width !== undefined) this.opts.letterBorderWidth = width;
    if (color !== null && color !== undefined) this.opts.letterBorderColor = color;
    for (const n of this.letterNodes) {
      if (!n || n.tagName === 'BR') continue;
      // Solo aplicar borde si no es plano
      if (n.dataset.plain !== 'true') {
        n.style.border = this.opts.letterBorderWidth + 'px solid ' + this.opts.letterBorderColor;
      }
    }
  }

  setTextColor(color) {
    this.opts.textColor = color;
    for (const n of this.letterNodes) {
      if (!n || n.tagName === 'BR') continue;
      // Solo cambiar color si no es plano
      if (n.dataset.plain !== 'true') {
        // MUSICOLI FIX: Always use black for Bravura musical notation
        const ch = n.textContent;
        const charCode = ch && ch.length > 0 ? ch.charCodeAt(0) : 0;
        if (charCode >= 0xE000 && charCode <= 0xF8FF) {
          n.style.color = '#000000'; // Force black for musical notation
        } else {
          n.style.color = color;
        }
      }
    }
  }

  setTextColorFunc(fn) {
    this.opts.textColorFunc = (typeof fn === 'function') ? fn : null;
    this.recolor();
  }

  setLetterMargin(marginX = 0) {
    this.opts.letterMarginX = marginX;
    const val = (typeof marginX === 'number') ? `0 ${marginX}px` : marginX;
    for (const n of this.letterNodes) {
      if (!n || n.tagName === 'BR') continue;
      n.style.margin = val;
    }
  }

  setTextAlign(align) {
    this.opts.textAlign = align;
    this.container.style.textAlign = align;
  }

  // ---------------- Events ----------------
  on(eventName, fn) {
    if (!this.handlers[eventName]) this.handlers[eventName] = [];
    this.handlers[eventName].push(fn);
  }

  destroy() {
    this._detachEvents();
    this.container.remove();
  }

  // ---------------- Export ----------------

  exportHTML() {
    const clone = this.container.cloneNode(true);
    // Remove internal UI elements
    const cursors = clone.getElementsByClassName('notepad-cursor');
    while (cursors.length > 0) cursors[0].remove();

    const textareas = clone.getElementsByTagName('textarea');
    while (textareas.length > 0) textareas[0].remove();

    return clone.outerHTML;
  }

  exportAsImageWithP5(filename = 'notepad.png', opts = {}) {
    if (typeof window.createGraphics !== 'function') {
      if (typeof this.exportAsImageCanvas === 'function') {
        return this.exportAsImageCanvas(filename, opts);
      } else {
        return Promise.reject(new Error('p5.createGraphics no disponible y no existe fallback canvas.'));
      }
    }

    return new Promise((resolve, reject) => {
      const scale = opts.scale || 2;
      const background = (typeof opts.background !== 'undefined') ? opts.background : this.container.style.background;
      const width = Math.max(1, this.container.scrollWidth);
      const height = Math.max(1, this.container.scrollHeight);

      try {
        const g = window.createGraphics(Math.round(width * scale), Math.round(height * scale));
        g.push();
        g.scale(scale);

        if (background !== null) g.background(background); else g.clear();

        // Configuraci√≥n de texto
        g.textSize(this.opts.fontSize);
        try { g.textFont(this.opts.fontFamily); } catch (e) { }
        g.textAlign(g.CENTER, g.CENTER); // Centrado

        const containerRect = this.container.getBoundingClientRect();

        for (let i = 0; i < this.letterNodes.length; i++) {
          const node = this.letterNodes[i];
          if (!node) continue;
          if (node.tagName === 'BR') continue;
          const r = node.getBoundingClientRect();
          const x = r.left - containerRect.left + this.container.scrollLeft;
          const y = r.top - containerRect.top + this.container.scrollTop;
          const w = Math.max(1, r.width);
          const h = Math.max(1, r.height);

          // Determinar color para exportaci√≥n
          let color;
          let isPlain = node.dataset.plain === 'true';

          if (isPlain) {
            color = 'transparent';
          } else {
            color = (node.dataset && node.dataset.color) ? node.dataset.color : '#000';
          }

          // Borde
          if (!isPlain && this.opts.letterBorderWidth > 0 && this.opts.letterBorderColor) {
            g.stroke(this.opts.letterBorderColor);
            g.strokeWeight(this.opts.letterBorderWidth);
          } else {
            g.noStroke();
          }

          const radius = this.opts.letterBorderRadius || 0;

          try {
            if (color !== 'transparent') {
              g.fill(color);
              g.rect(x, y, w, h, radius);
            } else if (!isPlain && this.opts.letterBorderWidth > 0) {
              // Si es transparente pero tiene borde
              g.noFill();
              g.rect(x, y, w, h, radius);
            }
          } catch (errRect) {
            if (color !== 'transparent') {
              g.fill(color);
              g.rect(x, y, w, h);
            }
          }

          g.noStroke();
          g.fill(node.style.color || this.opts.textColor || '#ffffff');
          // Ajuste para centrado: sumar mitad de ancho y alto
          g.text(node.textContent, x + w / 2, y + h / 2);
        }

        g.pop();

        const canvas = g.elt && g.elt.tagName === 'CANVAS' ? g.elt : (g.canvas || (g._renderer && g._renderer.canvas));
        if (!canvas) {
          return reject(new Error('No se pudo acceder al canvas del p5.Graphics'));
        }
        const dataUrl = canvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        resolve();
      } catch (err) {
        reject(err);
      }
    });
  }

  exportAsImageCanvas(filename = 'notepad.png', opts = {}) {
    return new Promise((resolve, reject) => {
      try {
        const scale = opts.scale || 2;
        const background = (typeof opts.background !== 'undefined') ? opts.background : this.container.style.background;
        const width = Math.max(1, this.container.scrollWidth);
        const height = Math.max(1, this.container.scrollHeight);
        const canvas = document.createElement('canvas');
        canvas.width = Math.round(width * scale);
        canvas.height = Math.round(height * scale);
        const ctx = canvas.getContext('2d');
        ctx.scale(scale, scale);

        if (background !== null) {
          ctx.fillStyle = background;
          ctx.fillRect(0, 0, width, height);
        } else {
          ctx.clearRect(0, 0, width, height);
        }

        const containerRect = this.container.getBoundingClientRect();
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.font = `${this.opts.fontSize}px ${this.opts.fontFamily || 'monospace'}`;

        for (let i = 0; i < this.letterNodes.length; i++) {
          const node = this.letterNodes[i];
          if (!node) continue;
          if (node.tagName === 'BR') continue;
          const r = node.getBoundingClientRect();
          const x = r.left - containerRect.left + this.container.scrollLeft;
          const y = r.top - containerRect.top + this.container.scrollTop;
          const w = r.width;
          const h = r.height;

          // Determinar color para exportaci√≥n
          let color;
          let isPlain = node.dataset.plain === 'true';

          if (isPlain) {
            // Si es modo plano, generalmente es transparente, pero chequeamos si necesitamos renderizar algo?
            // Normalmente no renderizamos el fondo, pero quizas texto.
            // Para consistencia con p5, tratamos.
            color = 'transparent';
          } else {
            color = (node.dataset && node.dataset.color) ? node.dataset.color : '#000';
          }

          const radius = this.opts.letterBorderRadius || 0;

          ctx.beginPath();
          // Round rect path
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + w - radius, y);
          ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
          ctx.lineTo(x + w, y + h - radius);
          ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
          ctx.lineTo(x + radius, y + h);
          ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();

          let hasStroke = false;
          if (!isPlain && this.opts.letterBorderWidth > 0 && this.opts.letterBorderColor) {
            ctx.lineWidth = this.opts.letterBorderWidth;
            ctx.strokeStyle = this.opts.letterBorderColor;
            hasStroke = true;
          }

          if (color !== 'transparent') {
            ctx.fillStyle = color;
            ctx.fill();
          }

          if (hasStroke) {
            ctx.stroke();
          }

          ctx.fillStyle = node.style.color || this.opts.textColor || '#ffffff';
          // Ajuste para centrado
          ctx.fillText(node.textContent, x + w / 2, y + h / 2);
        }

        canvas.toBlob(function (blob) {
          const a = document.createElement('a');
          const url = URL.createObjectURL(blob);
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          resolve();
        }, 'image/png');
      } catch (err) {
        reject(err);
      }
    });
  }

  // ---------------- Internal helpers ----------------

  _build() {
    this.container = document.createElement('div');
    this.container.className = 'notepad-container';
    this.container.tabIndex = 0;
    Object.assign(this.container.style, {
      width: (typeof this.opts.width === 'number') ? `${this.opts.width}px` : this.opts.width,
      height: (typeof this.opts.height === 'number') ? `${this.opts.height}px` : this.opts.height,
      border: '1px solid #ccc',
      padding: this.opts.containerPadding,
      fontFamily: this.opts.fontFamily,
      fontSize: this.opts.fontSize + 'px',
      lineHeight: '1',
      cursor: 'text',
      overflow: 'auto',
      userSelect: 'none',
      outline: 'none',
      background: 'white',
      backgroundImage: 'url(' + this.imagePath + ')',
      whiteSpace: 'pre-wrap',
      wordWrap: 'break-word',
      textAlign: this.opts.textAlign,
    });
    this.content = document.createElement('div');
    this.content.style.display = 'inline';
    this.container.appendChild(this.content);

    this.cursor = document.createElement('span');
    this.cursor.className = 'notepad-cursor';
    Object.assign(this.cursor.style, {
      display: 'inline-block',
      width: '2px',
      height: (this.opts.fontSize + 4) + 'px',
      backgroundColor: '#333',
      verticalAlign: 'text-bottom',
      animation: 'np-blink 1s steps(2,start) infinite',
    });

    if (!document.getElementById('notepad-style')) {
      const st = document.createElement('style');
      st.id = 'notepad-style';
      st.textContent = `
        @keyframes np-blink { 0%{opacity:1}50%{opacity:0}100%{opacity:1} }
        .notepad-letter-selected { outline: 2px solid rgba(0,0,0,0.15); box-shadow: inset 0 0 0 2px rgba(0,0,0,0.03); }
        /* SOLICITADO POR MUSICOLI: Visual mark for span at cursor position (ritmo/text modes) */
        .notepad-cursor-at { box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.5), inset 0 0 0 1px rgba(0, 123, 255, 0.3); }
        .notepad-newline { display: block; width: 0; height: 0; margin: 0; padding: 0; }
      `;
      document.head.appendChild(st);
    }

    this.parent = this.opts.parent || document.body;
    this.parent.appendChild(this.container);

    this.textarea = document.createElement('textarea');
    Object.assign(this.textarea.style, {
      position: 'absolute',
      opacity: '0',
      pointerEvents: 'none',
      width: '1px',
      height: '1px',
      top: '0',
      left: '0'
    });
    this.container.appendChild(this.textarea);

    this.textarea.addEventListener('focus', () => {
      this.cursor.style.display = 'inline-block';
    });
    this.textarea.addEventListener('blur', () => {
      this.cursor.style.display = 'none';
    });
  }

  _attachEvents() {
    // ... (c√≥digo de eventos, mantener igual que antes)
    this._onPointerDown = (e) => {
      e.preventDefault();

      // SOLICITADO POR MUSICOLI: Inicio - Emitir evento noteClick incluso en modo no editable
      let clickTarget = e.target;
      if (clickTarget.nodeType === 3) clickTarget = clickTarget.parentNode;

      if (clickTarget && clickTarget.dataset && typeof clickTarget.dataset.index !== 'undefined') {
        const idx = parseInt(clickTarget.dataset.index, 10);
        if (idx >= 0 && idx < this.letterNodes.length) {
          const node = this.letterNodes[idx];
          if (typeof this._emit === 'function') {
            this._emit('noteClick', {
              index: idx,
              text: node.textContent,
              color: node.dataset.color || node.style.color || node.style.backgroundColor,
              node: node,
              originalEvent: e
            });
          }

          // SOLICITADO POR MUSICOLI: Update cursor position for visual feedback even in non-editable mode
          // This allows the cursor mark to show where the user clicked in ritmo/text modes
          if (!this.isEditable) {
            const rect = clickTarget.getBoundingClientRect();
            const rectContainer = this.container.getBoundingClientRect();
            const clickX = e.clientX - rectContainer.left + this.container.scrollLeft;
            // Determine cursor position: left or right side of span
            if (e.clientX < rect.left + rect.width / 2) {
              this.cursorPos = idx;
            } else {
              this.cursorPos = idx + 1;
            }
            this.cursorPos = Math.max(0, Math.min(this.cursorPos, this.letterNodes.length));
            this._clearSelection();
            this._render();
            return;
          }
        }
      }
      // SOLICITADO POR MUSICOLI: Fin

      if (!this.isEditable) return;
      this.focus();

      const now = Date.now();
      const isDouble = (this._lastClickTime && (now - this._lastClickTime < 300));
      this._lastClickTime = now;

      if (isDouble) {
        let target = e.target;
        if (target.nodeType === 3) target = target.parentNode;
        if (target && target.dataset && typeof target.dataset.index !== 'undefined') {
          const idx = parseInt(target.dataset.index, 10);
          if (idx >= 0 && idx < this.letterNodes.length) {
            const node = this.letterNodes[idx];
            if (node.tagName !== 'BR') {
              this.editingIndex = idx;
              let offset = node.textContent.length;
              if (document.caretRangeFromPoint) {
                const range = document.caretRangeFromPoint(e.clientX, e.clientY);
                if (range) {
                  if (range.startContainer === node.firstChild) {
                    offset = range.startOffset;
                  } else if (range.startContainer === node) {
                    offset = (range.startOffset === 0) ? 0 : node.textContent.length;
                  }
                }
              } else if (document.caretPositionFromPoint) {
                const pos = document.caretPositionFromPoint(e.clientX, e.clientY);
                if (pos) {
                  if (pos.offsetNode === node.firstChild) {
                    offset = pos.offset;
                  } else if (pos.offsetNode === node) {
                    offset = (pos.offset === 0) ? 0 : node.textContent.length;
                  }
                }
              }
              this.editingOffset = offset;
              this._clearSelection();
              this._render();
              return;
            }
          }
        }
      }

      this.editingIndex = null;
      this._isTypingInWord = false;

      const rectContainer = this.container.getBoundingClientRect();
      const clickX = e.clientX - rectContainer.left + this.container.scrollLeft;
      const clickY = e.clientY;

      let idx = null;
      const target = e.target;

      if (target && target !== this.container && target !== this.content && target !== this.cursor && target.dataset && typeof target.dataset.index !== 'undefined') {
        const spanIndex = parseInt(target.dataset.index, 10);
        if (target.tagName === 'BR') {
          idx = spanIndex + 1;
        } else {
          const rect = target.getBoundingClientRect();
          if (e.clientX < rect.left + rect.width / 2) idx = spanIndex;
          else idx = spanIndex + 1;
        }
      }
      if (idx === null) {
        if (this.letterNodes.length > 0) {
          const lastNode = this.letterNodes[this.letterNodes.length - 1];
          const lastRect = lastNode.getBoundingClientRect();
          const lastRightX = lastRect.right - rectContainer.left + this.container.scrollLeft;
          if (clickX >= lastRightX) {
            idx = this.letterNodes.length;
          }
        } else {
          idx = 0;
        }
      }

      if (idx === null) idx = this._indexFromClientXY(e.clientX, e.clientY);

      idx = Math.max(0, Math.min(idx, this.letterNodes.length));

      if (e.shiftKey) {
        if (this.selectionStart === null) this.selectionStart = this.cursorPos;
        this.selectionEnd = idx;
        this.cursorPos = idx;
        this._render();
        return;
      }

      this.selectionStart = idx;
      this.selectionEnd = idx;
      this.cursorPos = idx;
      this.isDragging = true;
      this._render();
    };

    this._onPointerMove = (e) => {
      if (!this.isDragging) return;
      e.preventDefault();
      const idx = this._indexFromClientXY(e.clientX, e.clientY);
      this.selectionEnd = idx;
      this.cursorPos = idx;
      this._render();
    };

    this._onPointerUp = (e) => {
      if (!this.isDragging) return;
      this.isDragging = false;
      if (this.selectionStart === this.selectionEnd) this._clearSelection();
      this._render();
      this.textarea.focus();
    };

    this.container.addEventListener('pointerdown', this._onPointerDown);
    window.addEventListener('pointermove', this._onPointerMove);
    window.addEventListener('pointerup', this._onPointerUp);

    this.isComposing = false;

    this._onCompositionStart = (e) => {
      this.isComposing = true;
    };

    this._onCompositionEnd = (e) => {
      this.isComposing = false;
      if (e.data) {
        for (let char of e.data) {
          this._insertChar(char);
        }
        this._render();
        this._emit('change');
      }
      this.textarea.value = '';
    };

    this.textarea.addEventListener('compositionstart', this._onCompositionStart);
    this.textarea.addEventListener('compositionend', this._onCompositionEnd);

    this._onInput = (e) => {
      if (!this.isEditable) {
        this.textarea.value = '';
        return;
      }
      if (this.isComposing) return;

      const inputType = e.inputType;

      if (inputType === 'insertText' && e.data) {
        for (let char of e.data) {
          if (this.overwriteMode) this._overwriteChar(char);
          else this._insertChar(char);
        }
      } else if (inputType === 'insertLineBreak') {
        this._insertNewline();
      } else if (inputType === 'deleteContentBackward') {
        this._handleBackspace();
      } else if (inputType === 'deleteContentForward') {
        this._handleDelete();
      } else if (inputType === 'insertFromPaste') {
        // Paste handled by paste event
      }

      this.textarea.value = '';
      this._render();
      this._emit('change');
    };

    this.textarea.addEventListener('input', this._onInput);

    this._onKeyDown = (e) => {
      const ctrl = e.ctrlKey || e.metaKey;
      if (ctrl && e.key.toLowerCase() === 'c') { e.preventDefault(); this.copy(); return; }

      if (!this.isEditable) return;

      if (ctrl && e.key.toLowerCase() === 'x') { e.preventDefault(); this.cut(); return; }
      if (ctrl && e.key.toLowerCase() === 'v') { e.preventDefault(); this.paste(); return; }

      if (e.key === 'Enter') {
        e.preventDefault();
        if (this.editingIndex !== null) {
          this.cursorPos = this.editingIndex + 1;
          this.editingIndex = null;
        }
        this._insertNewline();
        this._render();
        this._emit('change');
        return;
      }

      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        if (this.editingIndex !== null) {
          if (this.editingOffset > 0) {
            this.editingOffset--;
            this._render();
          } else {
            this.cursorPos = this.editingIndex;
            this.editingIndex = null;
            this._render();
          }
          return;
        }
        this.cursorPos = Math.max(0, this.cursorPos - 1);
        this._clearSelection();
        this._isTypingInWord = false;
        this._render();
        return;
      }
      if (e.key === 'ArrowRight') {
        e.preventDefault();
        if (this.editingIndex !== null) {
          const node = this.letterNodes[this.editingIndex];
          if (this.editingOffset < node.textContent.length) {
            this.editingOffset++;
            this._render();
          } else {
            this.cursorPos = this.editingIndex + 1;
            this.editingIndex = null;
            this._render();
          }
          return;
        }
        this.cursorPos = Math.min(this.letterNodes.length, this.cursorPos + 1);
        this._clearSelection();
        this._isTypingInWord = false;
        this._render();
        return;
      }

      if (e.key === 'Backspace') {
        e.preventDefault();
        if (this.overwriteMode) this._handleOverwriteBackspace();
        else this._handleBackspace();
        return;
      }
      if (e.key === 'Delete') {
        e.preventDefault();
        if (this.overwriteMode) this._handleOverwriteDelete();
        else this._handleDelete();
        return;
      }

      if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
        e.preventDefault();
        if (this.overwriteMode) {
          this._overwriteChar(e.key);
        } else {
          this._insertChar(e.key);
        }
        this._render();
        this._emit('change');
      }
    };

    this.textarea.addEventListener('keydown', this._onKeyDown);
    this.container.addEventListener('keydown', (e) => {
      this.textarea.focus();
    });
  }

  _updateTextareaPosition() {
    try {
      const cursorRect = this.cursor.getBoundingClientRect();
      const containerRect = this.container.getBoundingClientRect();
      this.textarea.style.top = (cursorRect.top - containerRect.top + this.container.scrollTop) + 'px';
      this.textarea.style.left = (cursorRect.left - containerRect.left + this.container.scrollLeft) + 'px';
    } catch (e) { }
  }

  _handleBackspace() {
    if (this.editingIndex !== null) {
      const node = this.letterNodes[this.editingIndex];
      if (this.editingOffset > 0) {
        const text = node.textContent;
        const newText = text.slice(0, this.editingOffset - 1) + text.slice(this.editingOffset);
        node.textContent = newText;
        this.editingOffset--;
        this._render();
        this._emit('change');
      }
      return;
    }

    const range = this._getSelectionRange();
    if (range) { this.cut(); return; }
    if (this.cursorPos > 0) {
      this.letterNodes[this.cursorPos - 1].remove();
      this.letterNodes.splice(this.cursorPos - 1, 1);
      this.cursorPos--;
      this._render();
      this._emit('change');
    }
  }

  _handleDelete() {
    if (this.editingIndex !== null) {
      const node = this.letterNodes[this.editingIndex];
      const text = node.textContent;
      if (this.editingOffset < text.length) {
        const newText = text.slice(0, this.editingOffset) + text.slice(this.editingOffset + 1);
        node.textContent = newText;
        this._render();
        this._emit('change');
      }
      return;
    }

    const range = this._getSelectionRange();
    if (range) { this.cut(); return; }
    if (this.cursorPos < this.letterNodes.length) {
      this.letterNodes[this.cursorPos].remove();
      this.letterNodes.splice(this.cursorPos, 1);
      this._render();
      this._emit('change');
    }
  }

  _detachEvents() {
    this.container.removeEventListener('pointerdown', this._onPointerDown);
    window.removeEventListener('pointermove', this._onPointerMove);
    window.removeEventListener('pointerup', this._onPointerUp);
    this.textarea.removeEventListener('keydown', this._onKeyDown);
    this.textarea.removeEventListener('input', this._onInput);
    this.textarea.removeEventListener('compositionstart', this._onCompositionStart);
    this.textarea.removeEventListener('compositionend', this._onCompositionEnd);
  }

  // ---------------- Internal: insert / color lookup ----------------

  _insertChar(ch, explicitColor = null) {
    if (ch === '\n') { this._insertNewline(); return; }

    if (this.editingIndex !== null) {
      const node = this.letterNodes[this.editingIndex];
      if (node && node.tagName !== 'BR') {
        const text = node.textContent;
        const newText = text.slice(0, this.editingOffset) + ch + text.slice(this.editingOffset);
        node.textContent = newText;
        this.editingOffset++;
        this._render();
        this._emit('change');
        return;
      }
    }

    const sel = this._getSelectionRange();

    if (sel) {
      for (let i = sel.end - 1; i >= sel.start; i--) {
        this.letterNodes[i].remove();
        this.letterNodes.splice(i, 1);
      }
      this.cursorPos = sel.start;
      this._clearSelection();
    }

    const isSpace = ch === ' ';

    // Word mode handling
    if (this.opts.insertionMode === 'word' || this.opts.insertionMode === 'plain-word') {
      const prevNode = this.letterNodes[this.cursorPos - 1];

      if (isSpace) {
        const isPrevSpace = prevNode && prevNode.textContent === ' ';

        if (isPrevSpace) {
          const spaceSpan = document.createElement('span');
          spaceSpan.textContent = ' ';
          spaceSpan.style.display = 'inline-block';
          spaceSpan.style.backgroundColor = 'transparent';
          spaceSpan.style.color = 'transparent';
          spaceSpan.style.padding = `${this.opts.letterPadY}px ${this.opts.letterPadX}px`;
          spaceSpan.style.margin = (typeof this.opts.letterMarginX === 'number') ? `0 ${this.opts.letterMarginX}px` : this.opts.letterMarginX;
          spaceSpan.dataset.color = 'transparent';

          this.letterNodes.splice(this.cursorPos, 0, spaceSpan);
          this.cursorPos++;
          this._isTypingInWord = false;
          this._render();
          this._emit('change');
          return;
        } else {
          const spaceMarker = document.createElement('span');
          spaceMarker.textContent = ' ';
          spaceMarker.style.display = 'inline-block';
          spaceMarker.style.backgroundColor = 'transparent';
          spaceMarker.style.color = 'transparent';
          spaceMarker.style.padding = '0';
          spaceMarker.style.margin = '0';
          spaceMarker.style.width = '0';
          spaceMarker.style.overflow = 'hidden';
          spaceMarker.dataset.color = 'transparent';
          spaceMarker.dataset.invisibleSpace = 'true';

          this.letterNodes.splice(this.cursorPos, 0, spaceMarker);
          this.cursorPos++;
          this._isTypingInWord = false;
          this._render();
          this._emit('change');
          return;
        }
      } else {
        const canAppendToPrev = this._isTypingInWord &&
          prevNode &&
          prevNode.tagName === 'SPAN' &&
          prevNode.textContent.trim() !== '' &&
          !prevNode.dataset.invisibleSpace;

        if (canAppendToPrev) {
          prevNode.textContent += ch;
          this._isTypingInWord = true;
          this._render();
          this._emit('change');
          return;
        }
      }
    }

    // Create new span
    const span = document.createElement('span');
    span.textContent = ch;

    // Determine if we're in a plain mode
    const isPlainMode = this.opts.insertionMode.startsWith('plain-') || this._plainTextMode;
    const color = explicitColor || this._getColorForChar(ch);

    if (isPlainMode) {
      // Plain mode: transparent background, black text, no border
      span.style.backgroundColor = 'transparent';

      // MUSICOLI FIX: Always use black for Bravura musical notation
      const charCode = ch.charCodeAt(0);
      if (charCode >= 0xE000 && charCode <= 0xF8FF) {
        span.style.color = '#000000'; // Force black for musical notation
      } else {
        span.style.color = this._plainTextColor;
      }

      span.style.border = 'none';
      span.dataset.plain = 'true';
    } else {
      // Color mode: colored background, calculated text color
      span.style.backgroundColor = isSpace ? 'transparent' : color;
      span.style.color = this._resolveTextColor(ch, this.cursorPos, color);
      span.style.background = color;
      //-->span.style.backgroundImage = 'url(' + this.images[this.cursorPos] + ')';
      //-->span.style.backgroundSize = 'cover';
      span.style.border = this.opts.letterBorderWidth + 'px solid ' + this.opts.letterBorderColor;
      span.dataset.plain = 'false';
    }

    // Common styles
    span.style.display = 'inline-block';
    span.style.padding = `${this.opts.letterPadY}px ${this.opts.letterPadX}px`;
    span.style.margin = (typeof this.opts.letterMarginX === 'number') ? `0 ${this.opts.letterMarginX}px` : this.opts.letterMarginX;
    span.style.borderRadius = this.opts.letterBorderRadius + 'px';
    span.dataset.color = color;

    this.letterNodes.splice(this.cursorPos, 0, span);
    this.cursorPos++;

    // Set typing flag for word mode
    if (!isSpace && (this.opts.insertionMode === 'word' || this.opts.insertionMode === 'plain-word')) {
      this._isTypingInWord = true;
    }
  }

  _insertNewline() {
    if (this.editingIndex !== null) {
      this.cursorPos = this.editingIndex + 1;
      this.editingIndex = null;
    }
    if (this.overwriteMode) return;
    const sel = this._getSelectionRange();
    if (sel) {
      for (let i = sel.end - 1; i >= sel.start; i--) {
        this.letterNodes[i].remove();
        this.letterNodes.splice(i, 1);
      }
      this.cursorPos = sel.start;
      this._clearSelection();
    }
    const br = document.createElement('br');
    br.className = 'notepad-newline';
    this.letterNodes.splice(this.cursorPos, 0, br);
    this.cursorPos++;
  }

  _overwriteChar(ch) {
    const sel = this._getSelectionRange();
    if (sel) {
      const firstNode = this.letterNodes[sel.start];
      if (firstNode && firstNode.tagName !== 'BR') firstNode.textContent = ch;
      for (let i = sel.start + 1; i < sel.end; i++) {
        const n = this.letterNodes[i];
        if (n && n.tagName !== 'BR') n.textContent = ' ';
      }
      this.cursorPos = sel.start + 1;
      this._clearSelection();
    } else {
      if (this.cursorPos >= this.letterNodes.length) return;
      const node = this.letterNodes[this.cursorPos];
      if (node && node.tagName !== 'BR') {
        node.textContent = ch;
        this.cursorPos++;
      }
    }
  }

  _handleOverwriteBackspace() {
    const range = this._getSelectionRange();
    if (range) {
      for (let i = range.start; i < range.end; i++) {
        const n = this.letterNodes[i];
        if (n && n.tagName !== 'BR') n.textContent = ' ';
      }
      this.cursorPos = range.start;
      this._clearSelection();
      this._render();
      this._emit('change');
      return;
    }

    if (this.cursorPos > 0) {
      const prevIdx = this.cursorPos - 1;
      const node = this.letterNodes[prevIdx];
      if (node && node.tagName !== 'BR') {
        node.textContent = ' ';
        this.cursorPos--;
        this._render();
        this._emit('change');
      }
    }
  }

  _handleOverwriteDelete() {
    const range = this._getSelectionRange();
    if (range) {
      for (let i = range.start; i < range.end; i++) {
        const n = this.letterNodes[i];
        if (n && n.tagName !== 'BR') n.textContent = ' ';
      }
      this.cursorPos = range.start;
      this._clearSelection();
      this._render();
      this._emit('change');
      return;
    }
    if (this.cursorPos < this.letterNodes.length) {
      const node = this.letterNodes[this.cursorPos];
      if (node && node.tagName !== 'BR') {
        node.textContent = ' ';
        this._render();
        this._emit('change');
      }
    }
  }

  _getColorForChar(ch) {
    if (this.opts.noteColorMap && typeof this.opts.noteColorMap === 'object') {
      if (this.opts.noteColorMap.hasOwnProperty(ch)) { this._seqIndex++; return this.opts.noteColorMap[ch]; }
      const lower = ch.toLowerCase();
      if (this.opts.noteColorMap.hasOwnProperty(lower)) { this._seqIndex++; return this.opts.noteColorMap[lower]; }
    }

    if (typeof this.opts.colorFunc === 'function') {
      try {
        const c = this.opts.colorFunc(ch, this.letterNodes.length, this._seqIndex);
        if (c) { this._seqIndex++; return c; }
      } catch (e) { console.error('colorFunc error', e); }
    }

    if (this.opts.colorMap && typeof this.opts.colorMap === 'object') {
      if (this.opts.colorMap.hasOwnProperty(ch)) { this._seqIndex++; return this.opts.colorMap[ch]; }
      const lower = ch.toLowerCase();
      if (this.opts.colorMap.hasOwnProperty(lower)) { this._seqIndex++; return this.opts.colorMap[lower]; }
    }

    if (Array.isArray(this.opts.colorSequence) && this.opts.colorSequence.length) {
      const c = this.opts.colorSequence[this._seqIndex % this.opts.colorSequence.length];
      this._seqIndex++;
      return c;
    }

    const c = this.opts.colors[this._seqIndex % this.opts.colors.length];
    this._seqIndex++;
    return c;
  }

  _deterministicColorForChar(ch, pos) {
    if (this.opts.noteColorMap && typeof this.opts.noteColorMap === 'object') {
      if (this.opts.noteColorMap.hasOwnProperty(ch)) return this.opts.noteColorMap[ch];
      const lower = ch.toLowerCase();
      if (this.opts.noteColorMap.hasOwnProperty(lower)) return this.opts.noteColorMap[lower];
    }

    if (typeof this.opts.colorFunc === 'function') {
      try {
        const c = this.opts.colorFunc(ch, pos, pos);
        if (c) return c;
      } catch (e) { console.error('colorFunc error', e); }
    }

    if (this.opts.colorMap && typeof this.opts.colorMap === 'object') {
      if (this.opts.colorMap.hasOwnProperty(ch)) return this.opts.colorMap[ch];
      const lower = ch.toLowerCase();
      if (this.opts.colorMap.hasOwnProperty(lower)) return this.opts.colorMap[lower];
    }

    if (Array.isArray(this.opts.colorSequence) && this.opts.colorSequence.length) {
      return this.opts.colorSequence[pos % this.opts.colorSequence.length];
    }

    return this.opts.colors[pos % this.opts.colors.length];
  }

  _resolveTextColor(ch, index, bgColor) {
    // MUSICOLI FIX: Always use black for Bravura musical notation characters
    // Check if the character is a Bravura music symbol (Unicode range E000-F8FF is Private Use Area)
    const charCode = ch.charCodeAt(0);
    if (charCode >= 0xE000 && charCode <= 0xF8FF) {
      return '#000000'; // Always black for musical notation
    }

    if (typeof this.opts.textColorFunc === 'function') {
      try {
        const c = this.opts.textColorFunc(ch, index, bgColor);
        if (c) return c;
      } catch (e) { console.error('textColorFunc error', e); }
    }
    return this.opts.textColor;
  }

  _clearAll() {
    for (let n of this.letterNodes) n.remove();
    this.letterNodes = [];
    this.cursorPos = 0;
    this._clearSelection();
    this._seqIndex = 0;
    this.editingIndex = null;
    this._originalStates = null;
    this._isTypingInWord = false;
  }

  _render() {
    this.content.innerHTML = '';
    for (let i = 0; i < this.letterNodes.length; i++) {
      const node = this.letterNodes[i];
      node.dataset.index = i;
      // MUSICOLI: Skip raw textContent assignment if node has custom HTML content
      if (this.editingIndex !== i && node.childNodes.length > 1 && node.dataset.customContent !== 'true') {
        node.textContent = node.textContent;
      }
    }

    if (this.editingIndex !== null && this.editingIndex < this.letterNodes.length) {
      for (let i = 0; i < this.letterNodes.length; i++) {
        this.content.appendChild(this.letterNodes[i]);
      }
      const node = this.letterNodes[this.editingIndex];
      const text = node.textContent;
      node.innerHTML = '';
      const part1 = text.slice(0, this.editingOffset);
      const part2 = text.slice(this.editingOffset);
      node.appendChild(document.createTextNode(part1));
      node.appendChild(this.cursor);
      node.appendChild(document.createTextNode(part2));
      this.cursor.style.display = 'inline-block';
    } else {
      let placeCursorInside = false;
      let targetNode = null;

      if ((this.opts.insertionMode === 'word' || this.opts.insertionMode === 'plain-word') &&
        this.cursorPos > 0 && this._isTypingInWord) {
        const prevNode = this.letterNodes[this.cursorPos - 1];
        if (prevNode &&
          prevNode.tagName === 'SPAN' &&
          !prevNode.dataset.invisibleSpace &&
          prevNode.textContent.trim() !== '') {
          placeCursorInside = true;
          targetNode = prevNode;
        }
      }

      if (placeCursorInside && targetNode) {
        for (let i = 0; i < this.letterNodes.length; i++) {
          if (this.letterNodes[i] === targetNode) {
            const text = targetNode.textContent;
            targetNode.innerHTML = '';
            targetNode.appendChild(document.createTextNode(text));
            targetNode.appendChild(this.cursor);
            this.content.appendChild(targetNode);
          } else {
            this.content.appendChild(this.letterNodes[i]);
          }
        }
      } else {
        for (let i = 0; i < this.cursorPos; i++) this.content.appendChild(this.letterNodes[i]);
        this.content.appendChild(this.cursor);
        for (let i = this.cursorPos; i < this.letterNodes.length; i++) this.content.appendChild(this.letterNodes[i]);
      }
    }
    //this.backgroundEqualizer()
    this._updateSelectionVisual();
    // SOLICITADO POR MUSICOLI: Update cursor visual mark for ritmo/text modes
    this._updateCursorVisual();
    this._updatePerspectiveVisual();
    this._updateTextareaPosition();

  }

  _updateSelectionVisual() {
    for (let i = 0; i < this.letterNodes.length; i++) {
      const n = this.letterNodes[i];
      if (n.tagName === 'BR') continue;
      n.classList.remove('notepad-letter-selected');
    }
    const r = this._getSelectionRange();
    if (!r) return;
    for (let i = r.start; i < r.end; i++) {
      const n = this.letterNodes[i];
      if (n && n.tagName !== 'BR') n.classList.add('notepad-letter-selected');
    }
  }

  // SOLICITADO POR MUSICOLI: Visual feedback for cursor position in ritmo/text modes
  // Marks the span where the cursor is positioned to show where new compases would be inserted
  _updateCursorVisual() {
    // Remove cursor mark from all spans
    for (let i = 0; i < this.letterNodes.length; i++) {
      const n = this.letterNodes[i];
      if (n.tagName === 'BR') continue;
      n.classList.remove('notepad-cursor-at');
    }

    // Mark the span at cursor position
    // If cursorPos > 0, mark the span before cursor (left side)
    // If cursorPos == 0 and there are spans, mark the first span
    if (this.letterNodes.length > 0) {
      let spanToMark = null;
      if (this.cursorPos > 0) {
        // Mark the span to the left of cursor
        spanToMark = this.letterNodes[this.cursorPos - 1];
      } else if (this.cursorPos === 0) {
        // At the beginning, mark the first span if it exists
        spanToMark = this.letterNodes[0];
      }

      if (spanToMark && spanToMark.tagName !== 'BR') {
        spanToMark.classList.add('notepad-cursor-at');
      }
    }
  }

  _getSelectionRange() {
    if (this.selectionStart === null || this.selectionEnd === null) return null;
    const s = Math.min(this.selectionStart, this.selectionEnd);
    const e = Math.max(this.selectionStart, this.selectionEnd);
    if (s === e) return null;
    return { start: s, end: e };
  }

  _clearSelection() {
    this.selectionStart = null;
    this.selectionEnd = null;
    this._updateSelectionVisual();
  }

  _indexFromClientXY(clientX, clientY) {
    const rectContainer = this.container.getBoundingClientRect();
    if (this.letterNodes.length === 0) return 0;

    const infos = this.letterNodes.map((node, idx) => {
      const r = node.getBoundingClientRect();
      return {
        idx,
        node,
        left: r.left,
        right: r.right,
        top: r.top,
        bottom: r.bottom,
        centerX: r.left + (r.width / 2),
        centerY: r.top + (r.height / 2)
      };
    });

    let minVD = Infinity, best = 0;
    for (let i = 0; i < infos.length; i++) {
      const vd = Math.abs(infos[i].centerY - clientY);
      if (vd < minVD) { minVD = vd; best = i; }
    }

    const lineCenterY = infos[best].centerY;
    const lineThreshold = Math.max((this.opts.fontSize || 16) * 0.8, 8);

    const lineNodes = infos.filter(info => Math.abs(info.centerY - lineCenterY) <= lineThreshold);
    if (lineNodes.length === 0) return infos[best].idx;

    lineNodes.sort((a, b) => a.left - b.left);

    if (clientX < lineNodes[0].centerX) return lineNodes[0].idx;

    for (let i = 0; i < lineNodes.length; i++) {
      if (clientX < lineNodes[i].centerX) return lineNodes[i].idx;
    }

    const lastOnLine = lineNodes[lineNodes.length - 1].idx;
    return lastOnLine + 1;
  }

  _randomColor() { return this.opts.colors[Math.floor(Math.random() * this.opts.colors.length)]; }

  _emit(eventName, payload) {
    if (!this.handlers[eventName]) return;
    for (const fn of this.handlers[eventName]) {
      try { fn(payload); } catch (e) { console.error(e); }
    }
  }

  _parseColor(colorString) {
    if (!colorString || colorString === 'transparent') {
      return null;
    }

    // 1. Detectar degradado CSS
    if (colorString.startsWith('linear-gradient(') ||
      colorString.startsWith('radial-gradient(') ||
      colorString.includes('gradient')) {

      return {
        type: 'gradient',
        value: colorString   // se enviar√° tal cual al estilo del span
      };
    }

    // 2. HEX (#fff o #ffffff)
    if (colorString.startsWith('#')) {
      const hex = colorString.slice(1);
      if (hex.length === 3) {
        return {
          r: parseInt(hex[0] + hex[0], 16),
          g: parseInt(hex[1] + hex[1], 16),
          b: parseInt(hex[2] + hex[2], 16),
          type: 'rgb'
        };
      } else if (hex.length === 6) {
        return {
          r: parseInt(hex.slice(0, 2), 16),
          g: parseInt(hex.slice(2, 4), 16),
          b: parseInt(hex.slice(4, 6), 16),
          type: 'rgb'
        };
      }
    }

    // 3. rgb() o rgba()
    const rgbMatch = colorString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
    if (rgbMatch) {
      return {
        r: parseInt(rgbMatch[1]),
        g: parseInt(rgbMatch[2]),
        b: parseInt(rgbMatch[3]),
        type: 'rgb'
      };
    }

    return null;
  }

  _parseColorPlain(colorString) {
    if (!colorString || colorString === 'transparent') {
      return null;
    }

    if (colorString.startsWith('#')) {
      const hex = colorString.slice(1);
      if (hex.length === 3) {
        return {
          r: parseInt(hex[0] + hex[0], 16),
          g: parseInt(hex[1] + hex[1], 16),
          b: parseInt(hex[2] + hex[2], 16)
        };
      } else if (hex.length === 6) {
        return {
          r: parseInt(hex.slice(0, 2), 16),
          g: parseInt(hex.slice(2, 4), 16),
          b: parseInt(hex.slice(4, 6), 16)
        };
      }
    }

    const rgbMatch = colorString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
    if (rgbMatch) {
      return {
        r: parseInt(rgbMatch[1]),
        g: parseInt(rgbMatch[2]),
        b: parseInt(rgbMatch[3])
      };
    }

    return null;
  }

  // ---------------- Static Color Helpers ----------------

  static get ALPHABET() {
    return "abcdefghijklmnopqrstuvwxyz1234567890".split("");
  }

  static generateRainbowColors(steps) {
    const rainbowColors = [];
    for (let i = 0; i < steps; i++) {
      const hue = (i / steps) * 360;
      rainbowColors.push(`hsl(${hue}, 100%, 50%)`);
    }
    return rainbowColors;
  }

  static generateGreyScaleColors(steps) {
    const greyScaleColors = [];
    for (let i = 0; i < steps; i++) {
      const lightness = (i / steps) * 100;
      greyScaleColors.push(`hsl(0, 0%, ${lightness}%)`);
    }
    return greyScaleColors;
  }

  static generateWarmColors(steps) {
    return Array.from({ length: steps }, (_, i) => {
      const ratio = i / (steps - 1);
      const r = Math.round(255);
      const g = Math.round(50 + (ratio * 170));
      const b = Math.round(0);
      return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    });
  }

  static generateColdColors(steps) {
    return Array.from({ length: steps }, (_, i) => {
      const ratio = i / (steps - 1);
      const r = Math.round(50 + (ratio * 170));
      const g = Math.round(50 + (ratio * 170));
      const b = Math.round(255);
      return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    });
  }
  static generateDarkLightColors(steps) {
    const darkLightColors = [];
    let l = 50;
    for (let i = 0; i < steps; i++) {
      const hue = (i / steps) * 360;
      if (i % 2 == 0) {
        l = 50;
      } else {
        l = 20;
      }
      darkLightColors.push(`hsl(${hue}, 100%, ${l}%)`);
    }
    return darkLightColors;
  }

  static generateRandomColors(steps = 10) {
    const randomColors = [];
    for (let i = 0; i < steps; i++) {
      const r = Math.floor(Math.random() * 256);
      const g = Math.floor(Math.random() * 256);
      const b = Math.floor(Math.random() * 256);
      randomColors.push(`rgb(${r}, ${g}, ${b})`);
    }
    return randomColors;
  }

  static generateGradientColors(colors) {
    let cycleIndex = 0;
    function colorFunc(char, index) {
      if (index === 0) cycleIndex = 0;
      if (char === ' ') return 'transparent';

      const a = colors[cycleIndex % colors.length];
      const b = colors[(cycleIndex + 1) % colors.length];

      cycleIndex++;
      return `linear-gradient(to bottom, ${a}, ${b})`;
    }
    return colorFunc;
  }

  static assignRainbowColors(letters = Notepad.ALPHABET) {
    const rainbowColors = Notepad.generateRainbowColors(letters.length);
    let colorMap = {};
    letters.forEach((letter, index) => {
      colorMap[letter] = rainbowColors[index];
    });
    return colorMap;
  }

  static assignRandomColors(letters = Notepad.ALPHABET) {
    const randomColors = Notepad.generateRandomColors(letters.length);
    let colorMap = {};
    letters.forEach((letter, index) => {
      colorMap[letter] = randomColors[index];
    });
    return colorMap;
  }


  static assignGradientColors(letters = Notepad.ALPHABET) {
    const randomColors = Notepad.generateRandomColors(letters.length);
    const colori = Notepad.generateGradientColors(randomColors);
    let colorMap = {};
    letters.forEach((letter, index) => {
      colorMap[letter] = colori(letter, index);
    });
    return colorMap;
  }

  static getContrastColor(colorString) {
    if (!colorString || colorString === 'transparent') return '#000000';
    let r = 0, g = 0, b = 0;
    if (colorString.startsWith('#')) {
      const hex = colorString.slice(1);
      if (hex.length === 3) {
        r = parseInt(hex[0] + hex[0], 16);
        g = parseInt(hex[1] + hex[1], 16);
        b = parseInt(hex[2] + hex[2], 16);
      } else if (hex.length === 6) {
        r = parseInt(hex.slice(0, 2), 16);
        g = parseInt(hex.slice(2, 4), 16);
        b = parseInt(hex.slice(4, 6), 16);
      }
    } else if (colorString.startsWith('rgb')) {
      const match = colorString.match(/\d+/g);
      if (match && match.length >= 3) {
        r = parseInt(match[0]);
        g = parseInt(match[1]);
        b = parseInt(match[2]);
      }
    } else if (colorString.startsWith('hsl')) {
      const match = colorString.match(/hsl\(\s*\d+\s*,\s*\d+%\s*,\s*(\d+)%\s*\)/);
      if (match) {
        return parseInt(match[1]) > 50 ? '#000000' : '#ffffff';
      }
      return '#000000';
    }
    const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return (yiq >= 128) ? '#000000' : '#ffffff';
  }

  static getComplementaryColor(colorString) {
    if (!colorString || colorString === 'transparent') return '#000000';
    const hslMatch = colorString.match(/hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/);
    if (hslMatch) {
      const h = parseInt(hslMatch[1]);
      const s = parseInt(hslMatch[2]);
      const l = parseInt(hslMatch[3]);
      const newH = (h + 180) % 360;
      return `hsl(${newH}, ${s}%, ${l}%)`;
    }
    if (colorString.startsWith('#')) {
      const hex = colorString.slice(1);
      const num = parseInt(hex, 16);
      const inverted = 0xFFFFFF ^ num;
      return '#' + inverted.toString(16).padStart(6, '0');
    }
    return '#000000';
  }

  // SOLICITADO POR MUSICOLI: Helper para generar degradados horizontales
  static createHorizontalGradient(colors) {
    if (Array.isArray(colors)) {
      if (colors.length === 0) return 'transparent';
      if (colors.length === 1) return colors[0];
      return `linear-gradient(90deg, ${colors.join(', ')})`;
    }
    return colors;
  }
}

if (typeof module !== 'undefined' && module.exports) {
  module.exports = Notepad;
} else {
  window.Notepad = Notepad;
}